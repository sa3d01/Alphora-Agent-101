# src/agent.py

from dataclasses import dataclass
from typing import List, Dict, Any

from .classifier import Ticket, TicketClassification, RuleBasedClassifier
from .rag import RAGKnowledgeBase, RAGResult
from .actions import ToolExecutor, ActionResult
from typing import Optional


@dataclass
class ActionStep:
    action_name: str
    human_approval_required: bool
    context: Dict[str, Any]


@dataclass
class AgentDecision:
    ticket: Ticket
    classification: TicketClassification
    rag_results: List[RAGResult]
    action_plan: List[ActionStep]
    draft_reply: str
    requires_human: bool


class SupportAgent:
    """
    Alphora Agent 101 (mock).
    - Classifies tickets
    - Retrieves SOPs from a RAG knowledge base
    - Proposes an action plan (2-3 mock tools)
    - Drafts an email / response template
    """

    def __init__(
            self,
            kb: RAGKnowledgeBase,
            classifier: RuleBasedClassifier,
            tools: ToolExecutor,
            human_threshold: float = 0.7,
    ) -> None:
        self.kb = kb
        self.classifier = classifier
        self.tools = tools
        self.human_threshold = human_threshold

    def plan_actions(self, classification: TicketClassification, ticket: Ticket) -> List[ActionStep]:
        label = classification.label
        steps: List[ActionStep] = []

        if label == "password_reset":
            steps.append(
                ActionStep(
                    action_name="reset_password",
                    human_approval_required=True,
                    context={"username": "john.smith"},  # mocked mapping
                )
            )
        elif label in ("performance_issue", "system_restart"):
            steps.append(
                ActionStep(
                    action_name="restart_system",
                    human_approval_required=True,
                    context={"target": "FS-01"},
                )
            )
        elif label == "backup_failure":
            steps.append(
                ActionStep(
                    action_name="check_backup_status",
                    human_approval_required=False,
                    context={"backup_job": "GLOBEX-SQL-DAILY"},
                )
            )
        else:
            # unknown -> no automation
            pass

        return steps

    def generate_reply_template(
            self,
            ticket: Ticket,
            classification: TicketClassification,
            sop: Optional[RAGResult],
            actions: List[ActionStep],
            will_auto_execute: bool,
    ) -> str:
        base_intro = f"Hi,\n\nThanks for reaching out. This is an automated draft generated by Alphora Agent 101 for ticket {ticket.id}."

        label = classification.label
        if label == "password_reset":
            body = (
                "We detected that this ticket is likely related to a password or login issue.\n"
                "Our standard operating procedure is to first verify the user's identity and then perform a secure password reset.\n"
            )
        elif label in ("performance_issue", "system_restart"):
            body = (
                "We classified this as a performance or system stability incident.\n"
                "The next step is to investigate resource usage and, if appropriate, perform a controlled restart of the affected system.\n"
            )
        elif label == "backup_failure":
            body = (
                "We classified this as a backup failure.\n"
                "The procedure is to review backup logs, confirm the last successful restore point and re-run the job if needed.\n"
            )
        else:
            body = (
                "We could not confidently classify this ticket into a known automated category.\n"
                "A human technician should review and decide on next steps.\n"
            )

        if sop:
            sop_line = f"\nReference SOP: {sop.sop.title}\n"
        else:
            sop_line = ""

        actions_lines = ""
        if actions:
            actions_lines = "\nProposed actions:\n"
            for step in actions:
                approval = " (requires technician approval)" if step.human_approval_required else ""
                actions_lines += f" - {step.action_name}{approval}\n"

        exec_line = (
            "\nThese actions are queued and will only run after a technician approves them in the PSA."
            if actions
            else ""
        )

        closing = "\n\nBest regards,\nAlphora Agent 101\n"

        return base_intro + "\n\n" + body + sop_line + actions_lines + exec_line + closing

    def handle_ticket(self, ticket: Ticket) -> AgentDecision:
        classification = self.classifier.classify(ticket)

        query = f"{ticket.subject}\n{ticket.description}\nType: {classification.label}"
        rag_results = self.kb.retrieve(
            query=query,
            client_id=ticket.client_id,
            ticket_type=classification.label,
            top_k=3,
        )

        action_plan = self.plan_actions(classification, ticket)
        requires_human = (
                classification.confidence < self.human_threshold or not action_plan
        )

        top_sop = rag_results[0] if rag_results else None
        draft_reply = self.generate_reply_template(
            ticket=ticket,
            classification=classification,
            sop=top_sop,
            actions=action_plan,
            will_auto_execute=not requires_human,
        )

        return AgentDecision(
            ticket=ticket,
            classification=classification,
            rag_results=rag_results,
            action_plan=action_plan,
            draft_reply=draft_reply,
            requires_human=requires_human,
        )

    def execute_action_plan(self, decision: AgentDecision) -> List[ActionResult]:
        """
        For demo: execute all actions regardless of requires_human flag.
        In a real system, this would be triggered only after human approval.
        """
        results: List[ActionResult] = []
        for step in decision.action_plan:
            result = self.tools.execute(step.action_name, step.context)
            results.append(result)
        return results
